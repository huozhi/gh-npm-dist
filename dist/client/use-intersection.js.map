{"version":3,"sources":["../../client/use-intersection.tsx"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport {\n  requestIdleCallback,\n  cancelIdleCallback,\n} from './request-idle-callback'\n\ntype UseIntersectionObserverInit = Pick<\n  IntersectionObserverInit,\n  'rootMargin' | 'root'\n>\n\ntype UseIntersection = { disabled?: boolean } & UseIntersectionObserverInit & {\n    rootRef?: React.RefObject<HTMLElement> | null\n  }\ntype ObserveCallback = (isVisible: boolean) => void\ntype Identifier = {\n  root: Element | Document | null\n  margin: string\n}\ntype Observer = {\n  id: Identifier\n  observer: IntersectionObserver\n  elements: Map<Element, ObserveCallback>\n}\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined'\n\nexport function useIntersection<T extends Element>({\n  rootRef,\n  rootMargin,\n  disabled,\n}: UseIntersection): [(element: T | null) => void, boolean] {\n  const isDisabled: boolean = disabled || !hasIntersectionObserver\n\n  const unobserve = useRef<Function>()\n  const [visible, setVisible] = useState(false)\n  const [root, setRoot] = useState(rootRef ? rootRef.current : null)\n  const setRef = useCallback(\n    (el: T | null) => {\n      if (unobserve.current) {\n        unobserve.current()\n        unobserve.current = undefined\n      }\n\n      if (isDisabled || visible) return\n\n      if (el && el.tagName) {\n        unobserve.current = observe(\n          el,\n          (isVisible) => isVisible && setVisible(isVisible),\n          { root, rootMargin }\n        )\n      }\n    },\n    [isDisabled, root, rootMargin, visible]\n  )\n\n  useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = requestIdleCallback(() => setVisible(true))\n        return () => cancelIdleCallback(idleCallback)\n      }\n    }\n  }, [visible])\n\n  useEffect(() => {\n    if (rootRef) setRoot(rootRef.current)\n  }, [rootRef])\n  return [setRef, visible]\n}\n\nfunction observe(\n  element: Element,\n  callback: ObserveCallback,\n  options: UseIntersectionObserverInit\n): () => void {\n  const { id, observer, elements } = createObserver(options)\n  elements.set(element, callback)\n\n  observer.observe(element)\n  return function unobserve(): void {\n    elements.delete(element)\n    observer.unobserve(element)\n\n    // Destroy observer when there's nothing left to watch:\n    if (elements.size === 0) {\n      observer.disconnect()\n      observers.delete(id)\n      let index = idList.findIndex(\n        (obj) => obj.root === id.root && obj.margin === id.margin\n      )\n      if (index > -1) {\n        idList.splice(index, 1)\n      }\n    }\n  }\n}\n\nconst observers = new Map<Identifier, Observer>()\n\nconst idList: Identifier[] = []\n\nfunction createObserver(options: UseIntersectionObserverInit): Observer {\n  const id = {\n    root: options.root || null,\n    margin: options.rootMargin || '',\n  }\n  let existing = idList.find(\n    (obj) => obj.root === id.root && obj.margin === id.margin\n  )\n  let instance\n  if (existing) {\n    instance = observers.get(existing)\n  } else {\n    instance = observers.get(id)\n    idList.push(id)\n  }\n  if (instance) {\n    return instance\n  }\n\n  const elements = new Map<Element, ObserveCallback>()\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      const callback = elements.get(entry.target)\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0\n      if (callback && isVisible) {\n        callback(isVisible)\n      }\n    })\n  }, options)\n\n  observers.set(\n    id,\n    (instance = {\n      id,\n      observer,\n      elements,\n    })\n  )\n  return instance\n}\n"],"names":["useIntersection","hasIntersectionObserver","IntersectionObserver","rootRef","rootMargin","disabled","isDisabled","unobserve","visible","setVisible","root","setRoot","current","setRef","el","undefined","tagName","observe","isVisible","idleCallback","element","callback","options","id","observer","elements","createObserver","set","delete","size","disconnect","observers","index","idList","findIndex","obj","margin","splice","Map","existing","find","instance","get","push","entries","forEach","entry","target","isIntersecting","intersectionRatio"],"mappings":"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"}