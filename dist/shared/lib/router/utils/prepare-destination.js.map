{"version":3,"sources":["../../../../../shared/lib/router/utils/prepare-destination.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { Key } from 'next/dist/compiled/path-to-regexp'\nimport type { NextParsedUrlQuery } from '../../../../server/request-meta'\nimport type { Params } from '../../../../server/router'\nimport type { RouteHas } from '../../../../lib/load-custom-routes'\nimport type { BaseNextRequest } from '../../../../server/base-http'\n\nimport { compile, pathToRegexp } from 'next/dist/compiled/path-to-regexp'\nimport { escapeStringRegexp } from '../../escape-regexp'\nimport { parseUrl } from './parse-url'\n\nexport function matchHas(\n  req: BaseNextRequest | IncomingMessage,\n  has: RouteHas[],\n  query: Params\n): false | Params {\n  const params: Params = {}\n\n  const allMatch = has.every((hasItem) => {\n    let value: undefined | string\n    let key = hasItem.key\n\n    switch (hasItem.type) {\n      case 'header': {\n        key = key!.toLowerCase()\n        value = req.headers[key] as string\n        break\n      }\n      case 'cookie': {\n        value = (req as any).cookies[hasItem.key]\n        break\n      }\n      case 'query': {\n        value = query[key!]\n        break\n      }\n      case 'host': {\n        const { host } = req?.headers || {}\n        // remove port from host if present\n        const hostname = host?.split(':')[0].toLowerCase()\n        value = hostname\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key!)] = value\n      return true\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`)\n      const matches = Array.isArray(value)\n        ? value.slice(-1)[0].match(matcher)\n        : value.match(matcher)\n\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach((groupKey) => {\n              params[groupKey] = matches.groups![groupKey]\n            })\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0]\n          }\n        }\n        return true\n      }\n    }\n    return false\n  })\n\n  if (allMatch) {\n    return params\n  }\n  return false\n}\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return compile(`/${value}`, { validate: false })(params).substr(1)\n}\n\nexport function prepareDestination(args: {\n  appendParamsToQuery: boolean\n  destination: string\n  params: Params\n  query: NextParsedUrlQuery\n}) {\n  const query = Object.assign({}, args.query)\n  delete query.__nextLocale\n  delete query.__nextDefaultLocale\n\n  let escapedDestination = args.destination\n\n  for (const param of Object.keys({ ...args.params, ...query })) {\n    escapedDestination = escapeSegment(escapedDestination, param)\n  }\n\n  const parsedDestination = parseUrl(escapedDestination)\n  const destQuery = parsedDestination.query\n  const destPath = unescapeSegments(\n    `${parsedDestination.pathname!}${parsedDestination.hash || ''}`\n  )\n  const destHostname = unescapeSegments(parsedDestination.hostname || '')\n  const destPathParamKeys: Key[] = []\n  const destHostnameParamKeys: Key[] = []\n  pathToRegexp(destPath, destPathParamKeys)\n  pathToRegexp(destHostname, destHostnameParamKeys)\n\n  const destParams: (string | number)[] = []\n\n  destPathParamKeys.forEach((key) => destParams.push(key.name))\n  destHostnameParamKeys.forEach((key) => destParams.push(key.name))\n\n  const destPathCompiler = compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n\n  const destHostnameCompiler = compile(destHostname, { validate: false })\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map((value) =>\n        compileNonPath(unescapeSegments(value), args.params)\n      )\n    } else {\n      destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)\n    }\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(args.params).filter(\n    (name) => name !== 'nextInternalLocale'\n  )\n\n  if (\n    args.appendParamsToQuery &&\n    !paramKeys.some((key) => destParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key]\n      }\n    }\n  }\n\n  let newUrl\n\n  try {\n    newUrl = destPathCompiler(args.params)\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.hostname = destHostnameCompiler(args.params)\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err: any) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\nfunction getSafeParamName(paramName: string) {\n  let newParamName = ''\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i)\n\n    if (\n      (charCode > 64 && charCode < 91) || // A-Z\n      (charCode > 96 && charCode < 123) // a-z\n    ) {\n      newParamName += paramName[i]\n    }\n  }\n  return newParamName\n}\n\nfunction escapeSegment(str: string, segmentName: string) {\n  return str.replace(\n    new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),\n    `__ESC_COLON_${segmentName}`\n  )\n}\n\nfunction unescapeSegments(str: string) {\n  return str.replace(/__ESC_COLON_/gi, ':')\n}\n"],"names":["matchHas","compileNonPath","prepareDestination","req","has","query","params","allMatch","every","hasItem","value","key","type","toLowerCase","headers","cookies","host","hostname","split","getSafeParamName","matcher","RegExp","matches","Array","isArray","slice","match","groups","Object","keys","forEach","groupKey","includes","replace","validate","substr","args","assign","__nextLocale","__nextDefaultLocale","escapedDestination","destination","param","escapeSegment","parsedDestination","destQuery","destPath","unescapeSegments","pathname","hash","destHostname","destPathParamKeys","destHostnameParamKeys","destParams","push","name","destPathCompiler","destHostnameCompiler","strOrArray","entries","map","paramKeys","filter","appendParamsToQuery","some","newUrl","search","err","message","Error","paramName","newParamName","i","length","charCode","charCodeAt","str","segmentName"],"mappings":"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"}