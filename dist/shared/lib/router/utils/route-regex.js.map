{"version":3,"sources":["../../../../../shared/lib/router/utils/route-regex.ts"],"sourcesContent":["interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getParametrizedRoute(route: string) {\n  const segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97\n    let routeKeyCharLength = 1\n\n    // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = ''\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode)\n        routeKeyCharCode++\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++\n          routeKeyCharCode = 97\n        }\n      }\n      return routeKey\n    }\n\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = key.replace(/\\W/g, '')\n          let invalidKey = false\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true\n          }\n          if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n            invalidKey = true\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey()\n          }\n\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      parameterizedRoute,\n      namedParameterizedRoute,\n      groups,\n      routeKeys,\n    }\n  }\n\n  return {\n    parameterizedRoute,\n    groups,\n  }\n}\n\nexport interface RouteRegex {\n  groups: { [groupName: string]: Group }\n  namedRegex?: string\n  re: RegExp\n  routeKeys?: { [named: string]: string }\n}\n\nexport function getRouteRegex(normalizedRoute: string): RouteRegex {\n  const result = getParametrizedRoute(normalizedRoute)\n  if ('routeKeys' in result) {\n    return {\n      re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n      groups: result.groups,\n      routeKeys: result.routeKeys,\n      namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n    groups: result.groups,\n  }\n}\n"],"names":["getParametrizedRoute","getRouteRegex","escapeRegex","str","replace","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","route","segments","split","groups","groupIndex","parameterizedRoute","map","segment","pos","join","window","routeKeyCharCode","routeKeyCharLength","getSafeRouteKey","routeKey","i","String","fromCharCode","routeKeys","namedParameterizedRoute","cleanedKey","invalidKey","length","isNaN","parseInt","substr","normalizedRoute","result","re","RegExp","namedRegex"],"mappings":"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"}