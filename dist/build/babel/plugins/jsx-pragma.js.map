{"version":3,"sources":["../../../../build/babel/plugins/jsx-pragma.ts"],"sourcesContent":["import {\n  NodePath,\n  PluginObj,\n  types as BabelTypes,\n} from 'next/dist/compiled/babel/core'\nimport jsx from 'next/dist/compiled/babel/plugin-syntax-jsx'\n\nexport default function ({\n  types: t,\n}: {\n  types: typeof BabelTypes\n}): PluginObj<any> {\n  return {\n    inherits: jsx,\n    visitor: {\n      JSXElement(_path, state) {\n        state.set('jsx', true)\n      },\n\n      // Fragment syntax is still JSX since it compiles to createElement(),\n      // but JSXFragment is not a JSXElement\n      JSXFragment(_path, state) {\n        state.set('jsx', true)\n      },\n\n      Program: {\n        exit(path: NodePath<BabelTypes.Program>, state) {\n          if (state.get('jsx')) {\n            const pragma = t.identifier(state.opts.pragma)\n            let importAs = pragma\n\n            // if there's already a React in scope, use that instead of adding an import\n            const existingBinding =\n              state.opts.reuseImport !== false &&\n              state.opts.importAs &&\n              path.scope.getBinding(state.opts.importAs)\n\n            // var _jsx = _pragma.createElement;\n            if (state.opts.property) {\n              if (state.opts.importAs) {\n                importAs = t.identifier(state.opts.importAs)\n              } else {\n                importAs = path.scope.generateUidIdentifier('pragma')\n              }\n\n              const mapping = t.variableDeclaration('var', [\n                t.variableDeclarator(\n                  pragma,\n                  t.memberExpression(\n                    importAs,\n                    t.identifier(state.opts.property)\n                  )\n                ),\n              ])\n\n              // if the React binding came from a require('react'),\n              // make sure that our usage comes after it.\n              let newPath: NodePath<BabelTypes.VariableDeclaration>\n\n              if (\n                existingBinding &&\n                t.isVariableDeclarator(existingBinding.path.node) &&\n                t.isCallExpression(existingBinding.path.node.init) &&\n                t.isIdentifier(existingBinding.path.node.init.callee) &&\n                existingBinding.path.node.init.callee.name === 'require'\n              ) {\n                ;[newPath] =\n                  existingBinding.path.parentPath.insertAfter(mapping)\n              } else {\n                ;[newPath] = path.unshiftContainer('body', mapping)\n              }\n\n              for (const declar of newPath.get('declarations')) {\n                path.scope.registerBinding(\n                  newPath.node.kind,\n                  declar as NodePath<BabelTypes.Node>\n                )\n              }\n            }\n\n            if (!existingBinding) {\n              const importSpecifier = t.importDeclaration(\n                [\n                  state.opts.import\n                    ? // import { $import as _pragma } from '$module'\n                      t.importSpecifier(\n                        importAs,\n                        t.identifier(state.opts.import)\n                      )\n                    : state.opts.importNamespace\n                    ? t.importNamespaceSpecifier(importAs)\n                    : // import _pragma from '$module'\n                      t.importDefaultSpecifier(importAs),\n                ],\n                t.stringLiteral(state.opts.module || 'react')\n              )\n\n              const [newPath] = path.unshiftContainer('body', importSpecifier)\n              for (const specifier of newPath.get('specifiers')) {\n                path.scope.registerBinding(\n                  'module',\n                  specifier as NodePath<BabelTypes.Node>\n                )\n              }\n            }\n          }\n        },\n      },\n    },\n  }\n}\n"],"names":["types","t","inherits","visitor","JSXElement","_path","state","set","JSXFragment","Program","exit","path","get","pragma","identifier","opts","importAs","existingBinding","reuseImport","scope","getBinding","property","generateUidIdentifier","mapping","variableDeclaration","variableDeclarator","memberExpression","newPath","isVariableDeclarator","node","isCallExpression","init","isIdentifier","callee","name","parentPath","insertAfter","unshiftContainer","declar","registerBinding","kind","importSpecifier","importDeclaration","import","importNamespace","importNamespaceSpecifier","importDefaultSpecifier","stringLiteral","module","specifier"],"mappings":";;;;;AAKgB,GAA4C,CAA5C,gBAA4C;;;;;;kBAEnC,CAAC,CACxBA,KAAK,EAAEC,CAAC,EAGV,CAAC,EAAkB,CAAC;IAClB,MAAM,CAAC,CAAC;QACNC,QAAQ,EARI,gBAA4C;QASxDC,OAAO,EAAE,CAAC;YACRC,UAAU,EAACC,KAAK,EAAEC,KAAK,EAAE,CAAC;gBACxBA,KAAK,CAACC,GAAG,CAAC,CAAK,MAAE,IAAI;YACvB,CAAC;YAED,EAAqE,AAArE,mEAAqE;YACrE,EAAsC,AAAtC,oCAAsC;YACtCC,WAAW,EAACH,KAAK,EAAEC,KAAK,EAAE,CAAC;gBACzBA,KAAK,CAACC,GAAG,CAAC,CAAK,MAAE,IAAI;YACvB,CAAC;YAEDE,OAAO,EAAE,CAAC;gBACRC,IAAI,EAACC,IAAkC,EAAEL,KAAK,EAAE,CAAC;oBAC/C,EAAE,EAAEA,KAAK,CAACM,GAAG,CAAC,CAAK,OAAG,CAAC;wBACrB,KAAK,CAACC,MAAM,GAAGZ,CAAC,CAACa,UAAU,CAACR,KAAK,CAACS,IAAI,CAACF,MAAM;wBAC7C,GAAG,CAACG,QAAQ,GAAGH,MAAM;wBAErB,EAA4E,AAA5E,0EAA4E;wBAC5E,KAAK,CAACI,eAAe,GACnBX,KAAK,CAACS,IAAI,CAACG,WAAW,KAAK,KAAK,IAChCZ,KAAK,CAACS,IAAI,CAACC,QAAQ,IACnBL,IAAI,CAACQ,KAAK,CAACC,UAAU,CAACd,KAAK,CAACS,IAAI,CAACC,QAAQ;wBAE3C,EAAoC,AAApC,kCAAoC;wBACpC,EAAE,EAAEV,KAAK,CAACS,IAAI,CAACM,QAAQ,EAAE,CAAC;4BACxB,EAAE,EAAEf,KAAK,CAACS,IAAI,CAACC,QAAQ,EAAE,CAAC;gCACxBA,QAAQ,GAAGf,CAAC,CAACa,UAAU,CAACR,KAAK,CAACS,IAAI,CAACC,QAAQ;4BAC7C,CAAC,MAAM,CAAC;gCACNA,QAAQ,GAAGL,IAAI,CAACQ,KAAK,CAACG,qBAAqB,CAAC,CAAQ;4BACtD,CAAC;4BAED,KAAK,CAACC,OAAO,GAAGtB,CAAC,CAACuB,mBAAmB,CAAC,CAAK,MAAE,CAAC;gCAC5CvB,CAAC,CAACwB,kBAAkB,CAClBZ,MAAM,EACNZ,CAAC,CAACyB,gBAAgB,CAChBV,QAAQ,EACRf,CAAC,CAACa,UAAU,CAACR,KAAK,CAACS,IAAI,CAACM,QAAQ;4BAGtC,CAAC;4BAED,EAAqD,AAArD,mDAAqD;4BACrD,EAA2C,AAA3C,yCAA2C;4BAC3C,GAAG,CAACM,OAAO;4BAEX,EAAE,EACAV,eAAe,IACfhB,CAAC,CAAC2B,oBAAoB,CAACX,eAAe,CAACN,IAAI,CAACkB,IAAI,KAChD5B,CAAC,CAAC6B,gBAAgB,CAACb,eAAe,CAACN,IAAI,CAACkB,IAAI,CAACE,IAAI,KACjD9B,CAAC,CAAC+B,YAAY,CAACf,eAAe,CAACN,IAAI,CAACkB,IAAI,CAACE,IAAI,CAACE,MAAM,KACpDhB,eAAe,CAACN,IAAI,CAACkB,IAAI,CAACE,IAAI,CAACE,MAAM,CAACC,IAAI,KAAK,CAAS,UACxD,CAAC;iCACCP,OAAO,IACPV,eAAe,CAACN,IAAI,CAACwB,UAAU,CAACC,WAAW,CAACb,OAAO;4BACvD,CAAC,MAAM,CAAC;iCACJI,OAAO,IAAIhB,IAAI,CAAC0B,gBAAgB,CAAC,CAAM,OAAEd,OAAO;4BACpD,CAAC;4BAED,GAAG,EAAE,KAAK,CAACe,MAAM,IAAIX,OAAO,CAACf,GAAG,CAAC,CAAc,eAAG,CAAC;gCACjDD,IAAI,CAACQ,KAAK,CAACoB,eAAe,CACxBZ,OAAO,CAACE,IAAI,CAACW,IAAI,EACjBF,MAAM;4BAEV,CAAC;wBACH,CAAC;wBAED,EAAE,GAAGrB,eAAe,EAAE,CAAC;4BACrB,KAAK,CAACwB,eAAe,GAAGxC,CAAC,CAACyC,iBAAiB,CACzC,CAAC;gCACCpC,KAAK,CAACS,IAAI,CAAC4B,MAAM,GAEb1C,CAAC,CAACwC,eAAe,CACfzB,QAAQ,EACRf,CAAC,CAACa,UAAU,CAACR,KAAK,CAACS,IAAI,CAAC4B,MAAM,KAEhCrC,KAAK,CAACS,IAAI,CAAC6B,eAAe,GAC1B3C,CAAC,CAAC4C,wBAAwB,CAAC7B,QAAQ,IAEnCf,CAAC,CAAC6C,sBAAsB,CAAC9B,QAAQ;4BACvC,CAAC,EACDf,CAAC,CAAC8C,aAAa,CAACzC,KAAK,CAACS,IAAI,CAACiC,MAAM,IAAI,CAAO;4BAG9C,KAAK,EAAErB,OAAO,IAAIhB,IAAI,CAAC0B,gBAAgB,CAAC,CAAM,OAAEI,eAAe;4BAC/D,GAAG,EAAE,KAAK,CAACQ,SAAS,IAAItB,OAAO,CAACf,GAAG,CAAC,CAAY,aAAG,CAAC;gCAClDD,IAAI,CAACQ,KAAK,CAACoB,eAAe,CACxB,CAAQ,SACRU,SAAS;4BAEb,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC"}