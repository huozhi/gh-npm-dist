{"version":3,"sources":["../../../../build/babel/plugins/next-ssg-transform.ts"],"sourcesContent":["import {\n  NodePath,\n  PluginObj,\n  types as BabelTypes,\n} from 'next/dist/compiled/babel/core'\nimport { SERVER_PROPS_SSG_CONFLICT } from '../../../lib/constants'\nimport { SERVER_PROPS_ID, STATIC_PROPS_ID } from '../../../shared/lib/constants'\n\nexport const EXPORT_NAME_GET_STATIC_PROPS = 'getStaticProps'\nexport const EXPORT_NAME_GET_STATIC_PATHS = 'getStaticPaths'\nexport const EXPORT_NAME_GET_SERVER_PROPS = 'getServerSideProps'\n\nconst ssgExports = new Set([\n  EXPORT_NAME_GET_STATIC_PROPS,\n  EXPORT_NAME_GET_STATIC_PATHS,\n  EXPORT_NAME_GET_SERVER_PROPS,\n\n  // legacy methods added so build doesn't fail from importing\n  // server-side only methods\n  `unstable_getStaticProps`,\n  `unstable_getStaticPaths`,\n  `unstable_getServerProps`,\n  `unstable_getServerSideProps`,\n])\n\ntype PluginState = {\n  refs: Set<NodePath<BabelTypes.Identifier>>\n  isPrerender: boolean\n  isServerProps: boolean\n  done: boolean\n}\n\nfunction decorateSsgExport(\n  t: typeof BabelTypes,\n  path: NodePath<BabelTypes.Program>,\n  state: PluginState\n): void {\n  const gsspName = state.isPrerender ? STATIC_PROPS_ID : SERVER_PROPS_ID\n  const gsspId = t.identifier(gsspName)\n\n  const addGsspExport = (\n    exportPath:\n      | NodePath<BabelTypes.ExportDefaultDeclaration>\n      | NodePath<BabelTypes.ExportNamedDeclaration>\n  ): void => {\n    if (state.done) {\n      return\n    }\n    state.done = true\n\n    const [pageCompPath] = exportPath.replaceWithMultiple([\n      t.exportNamedDeclaration(\n        t.variableDeclaration(\n          // We use 'var' instead of 'let' or 'const' for ES5 support. Since\n          // this runs in `Program#exit`, no ES2015 transforms (preset env)\n          // will be ran against this code.\n          'var',\n          [t.variableDeclarator(gsspId, t.booleanLiteral(true))]\n        ),\n        [t.exportSpecifier(gsspId, gsspId)]\n      ),\n      exportPath.node,\n    ])\n    exportPath.scope.registerDeclaration(\n      pageCompPath as NodePath<BabelTypes.Node>\n    )\n  }\n\n  path.traverse({\n    ExportDefaultDeclaration(exportDefaultPath) {\n      addGsspExport(exportDefaultPath)\n    },\n    ExportNamedDeclaration(exportNamedPath) {\n      addGsspExport(exportNamedPath)\n    },\n  })\n}\n\nconst isDataIdentifier = (name: string, state: PluginState): boolean => {\n  if (ssgExports.has(name)) {\n    if (name === EXPORT_NAME_GET_SERVER_PROPS) {\n      if (state.isPrerender) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n      state.isServerProps = true\n    } else {\n      if (state.isServerProps) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n      state.isPrerender = true\n    }\n    return true\n  }\n  return false\n}\n\nexport default function nextTransformSsg({\n  types: t,\n}: {\n  types: typeof BabelTypes\n}): PluginObj<PluginState> {\n  function getIdentifier(\n    path:\n      | NodePath<BabelTypes.FunctionDeclaration>\n      | NodePath<BabelTypes.FunctionExpression>\n      | NodePath<BabelTypes.ArrowFunctionExpression>\n  ): NodePath<BabelTypes.Identifier> | null {\n    const parentPath = path.parentPath\n    if (parentPath.type === 'VariableDeclarator') {\n      const pp = parentPath as NodePath<BabelTypes.VariableDeclarator>\n      const name = pp.get('id')\n      return name.node.type === 'Identifier'\n        ? (name as NodePath<BabelTypes.Identifier>)\n        : null\n    }\n\n    if (parentPath.type === 'AssignmentExpression') {\n      const pp = parentPath as NodePath<BabelTypes.AssignmentExpression>\n      const name = pp.get('left')\n      return name.node.type === 'Identifier'\n        ? (name as NodePath<BabelTypes.Identifier>)\n        : null\n    }\n\n    if (path.node.type === 'ArrowFunctionExpression') {\n      return null\n    }\n\n    return path.node.id && path.node.id.type === 'Identifier'\n      ? (path.get('id') as NodePath<BabelTypes.Identifier>)\n      : null\n  }\n\n  function isIdentifierReferenced(\n    ident: NodePath<BabelTypes.Identifier>\n  ): boolean {\n    const b = ident.scope.getBinding(ident.node.name)\n    if (b?.referenced) {\n      // Functions can reference themselves, so we need to check if there's a\n      // binding outside the function scope or not.\n      if (b.path.type === 'FunctionDeclaration') {\n        return !b.constantViolations\n          .concat(b.referencePaths)\n          // Check that every reference is contained within the function:\n          .every((ref) => ref.findParent((p) => p === b.path))\n      }\n\n      return true\n    }\n    return false\n  }\n\n  function markFunction(\n    path:\n      | NodePath<BabelTypes.FunctionDeclaration>\n      | NodePath<BabelTypes.FunctionExpression>\n      | NodePath<BabelTypes.ArrowFunctionExpression>,\n    state: PluginState\n  ): void {\n    const ident = getIdentifier(path)\n    if (ident?.node && isIdentifierReferenced(ident)) {\n      state.refs.add(ident)\n    }\n  }\n\n  function markImport(\n    path:\n      | NodePath<BabelTypes.ImportSpecifier>\n      | NodePath<BabelTypes.ImportDefaultSpecifier>\n      | NodePath<BabelTypes.ImportNamespaceSpecifier>,\n    state: PluginState\n  ): void {\n    const local = path.get('local') as NodePath<BabelTypes.Identifier>\n    if (isIdentifierReferenced(local)) {\n      state.refs.add(local)\n    }\n  }\n\n  return {\n    visitor: {\n      Program: {\n        enter(path, state) {\n          state.refs = new Set<NodePath<BabelTypes.Identifier>>()\n          state.isPrerender = false\n          state.isServerProps = false\n          state.done = false\n\n          path.traverse(\n            {\n              VariableDeclarator(variablePath, variableState) {\n                if (variablePath.node.id.type === 'Identifier') {\n                  const local = variablePath.get(\n                    'id'\n                  ) as NodePath<BabelTypes.Identifier>\n                  if (isIdentifierReferenced(local)) {\n                    variableState.refs.add(local)\n                  }\n                } else if (variablePath.node.id.type === 'ObjectPattern') {\n                  const pattern = variablePath.get(\n                    'id'\n                  ) as NodePath<BabelTypes.ObjectPattern>\n\n                  const properties = pattern.get('properties')\n                  properties.forEach((p) => {\n                    const local = p.get(\n                      p.node.type === 'ObjectProperty'\n                        ? 'value'\n                        : p.node.type === 'RestElement'\n                        ? 'argument'\n                        : (function () {\n                            throw new Error('invariant')\n                          })()\n                    ) as NodePath<BabelTypes.Identifier>\n                    if (isIdentifierReferenced(local)) {\n                      variableState.refs.add(local)\n                    }\n                  })\n                } else if (variablePath.node.id.type === 'ArrayPattern') {\n                  const pattern = variablePath.get(\n                    'id'\n                  ) as NodePath<BabelTypes.ArrayPattern>\n\n                  const elements = pattern.get('elements')\n                  elements.forEach((e) => {\n                    let local: NodePath<BabelTypes.Identifier>\n                    if (e.node?.type === 'Identifier') {\n                      local = e as NodePath<BabelTypes.Identifier>\n                    } else if (e.node?.type === 'RestElement') {\n                      local = e.get(\n                        'argument'\n                      ) as NodePath<BabelTypes.Identifier>\n                    } else {\n                      return\n                    }\n\n                    if (isIdentifierReferenced(local)) {\n                      variableState.refs.add(local)\n                    }\n                  })\n                }\n              },\n              FunctionDeclaration: markFunction,\n              FunctionExpression: markFunction,\n              ArrowFunctionExpression: markFunction,\n              ImportSpecifier: markImport,\n              ImportDefaultSpecifier: markImport,\n              ImportNamespaceSpecifier: markImport,\n              ExportNamedDeclaration(exportNamedPath, exportNamedState) {\n                const specifiers = exportNamedPath.get('specifiers')\n                if (specifiers.length) {\n                  specifiers.forEach((s) => {\n                    if (\n                      isDataIdentifier(\n                        t.isIdentifier(s.node.exported)\n                          ? s.node.exported.name\n                          : s.node.exported.value,\n                        exportNamedState\n                      )\n                    ) {\n                      s.remove()\n                    }\n                  })\n\n                  if (exportNamedPath.node.specifiers.length < 1) {\n                    exportNamedPath.remove()\n                  }\n                  return\n                }\n\n                const decl = exportNamedPath.get('declaration') as NodePath<\n                  | BabelTypes.FunctionDeclaration\n                  | BabelTypes.VariableDeclaration\n                >\n                if (decl == null || decl.node == null) {\n                  return\n                }\n\n                switch (decl.node.type) {\n                  case 'FunctionDeclaration': {\n                    const name = decl.node.id!.name\n                    if (isDataIdentifier(name, exportNamedState)) {\n                      exportNamedPath.remove()\n                    }\n                    break\n                  }\n                  case 'VariableDeclaration': {\n                    const inner = decl.get(\n                      'declarations'\n                    ) as NodePath<BabelTypes.VariableDeclarator>[]\n                    inner.forEach((d) => {\n                      if (d.node.id.type !== 'Identifier') {\n                        return\n                      }\n                      const name = d.node.id.name\n                      if (isDataIdentifier(name, exportNamedState)) {\n                        d.remove()\n                      }\n                    })\n                    break\n                  }\n                  default: {\n                    break\n                  }\n                }\n              },\n            },\n            state\n          )\n\n          if (!state.isPrerender && !state.isServerProps) {\n            return\n          }\n\n          const refs = state.refs\n          let count: number\n\n          function sweepFunction(\n            sweepPath:\n              | NodePath<BabelTypes.FunctionDeclaration>\n              | NodePath<BabelTypes.FunctionExpression>\n              | NodePath<BabelTypes.ArrowFunctionExpression>\n          ): void {\n            const ident = getIdentifier(sweepPath)\n            if (\n              ident?.node &&\n              refs.has(ident) &&\n              !isIdentifierReferenced(ident)\n            ) {\n              ++count\n\n              if (\n                t.isAssignmentExpression(sweepPath.parentPath) ||\n                t.isVariableDeclarator(sweepPath.parentPath)\n              ) {\n                sweepPath.parentPath.remove()\n              } else {\n                sweepPath.remove()\n              }\n            }\n          }\n\n          function sweepImport(\n            sweepPath:\n              | NodePath<BabelTypes.ImportSpecifier>\n              | NodePath<BabelTypes.ImportDefaultSpecifier>\n              | NodePath<BabelTypes.ImportNamespaceSpecifier>\n          ): void {\n            const local = sweepPath.get(\n              'local'\n            ) as NodePath<BabelTypes.Identifier>\n            if (refs.has(local) && !isIdentifierReferenced(local)) {\n              ++count\n              sweepPath.remove()\n              if (\n                (sweepPath.parent as BabelTypes.ImportDeclaration).specifiers\n                  .length === 0\n              ) {\n                sweepPath.parentPath.remove()\n              }\n            }\n          }\n\n          do {\n            ;(path.scope as any).crawl()\n            count = 0\n\n            path.traverse({\n              // eslint-disable-next-line no-loop-func\n              VariableDeclarator(variablePath) {\n                if (variablePath.node.id.type === 'Identifier') {\n                  const local = variablePath.get(\n                    'id'\n                  ) as NodePath<BabelTypes.Identifier>\n                  if (refs.has(local) && !isIdentifierReferenced(local)) {\n                    ++count\n                    variablePath.remove()\n                  }\n                } else if (variablePath.node.id.type === 'ObjectPattern') {\n                  const pattern = variablePath.get(\n                    'id'\n                  ) as NodePath<BabelTypes.ObjectPattern>\n\n                  const beforeCount = count\n                  const properties = pattern.get('properties')\n                  properties.forEach((p) => {\n                    const local = p.get(\n                      p.node.type === 'ObjectProperty'\n                        ? 'value'\n                        : p.node.type === 'RestElement'\n                        ? 'argument'\n                        : (function () {\n                            throw new Error('invariant')\n                          })()\n                    ) as NodePath<BabelTypes.Identifier>\n\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count\n                      p.remove()\n                    }\n                  })\n\n                  if (\n                    beforeCount !== count &&\n                    pattern.get('properties').length < 1\n                  ) {\n                    variablePath.remove()\n                  }\n                } else if (variablePath.node.id.type === 'ArrayPattern') {\n                  const pattern = variablePath.get(\n                    'id'\n                  ) as NodePath<BabelTypes.ArrayPattern>\n\n                  const beforeCount = count\n                  const elements = pattern.get('elements')\n                  elements.forEach((e) => {\n                    let local: NodePath<BabelTypes.Identifier>\n                    if (e.node?.type === 'Identifier') {\n                      local = e as NodePath<BabelTypes.Identifier>\n                    } else if (e.node?.type === 'RestElement') {\n                      local = e.get(\n                        'argument'\n                      ) as NodePath<BabelTypes.Identifier>\n                    } else {\n                      return\n                    }\n\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count\n                      e.remove()\n                    }\n                  })\n\n                  if (\n                    beforeCount !== count &&\n                    pattern.get('elements').length < 1\n                  ) {\n                    variablePath.remove()\n                  }\n                }\n              },\n              FunctionDeclaration: sweepFunction,\n              FunctionExpression: sweepFunction,\n              ArrowFunctionExpression: sweepFunction,\n              ImportSpecifier: sweepImport,\n              ImportDefaultSpecifier: sweepImport,\n              ImportNamespaceSpecifier: sweepImport,\n            })\n          } while (count)\n\n          decorateSsgExport(t, path, state)\n        },\n      },\n    },\n  }\n}\n"],"names":["nextTransformSsg","EXPORT_NAME_GET_STATIC_PROPS","EXPORT_NAME_GET_STATIC_PATHS","EXPORT_NAME_GET_SERVER_PROPS","ssgExports","Set","decorateSsgExport","t","path","state","gsspName","isPrerender","gsspId","identifier","addGsspExport","exportPath","done","pageCompPath","replaceWithMultiple","exportNamedDeclaration","variableDeclaration","variableDeclarator","booleanLiteral","exportSpecifier","node","scope","registerDeclaration","traverse","ExportDefaultDeclaration","exportDefaultPath","ExportNamedDeclaration","exportNamedPath","isDataIdentifier","name","has","Error","isServerProps","types","getIdentifier","parentPath","type","pp","get","id","isIdentifierReferenced","ident","b","getBinding","referenced","constantViolations","concat","referencePaths","every","ref","findParent","p","markFunction","refs","add","markImport","local","visitor","Program","enter","VariableDeclarator","variablePath","variableState","pattern","properties","forEach","elements","e","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","exportNamedState","specifiers","length","s","isIdentifier","exported","value","remove","decl","inner","d","count","sweepFunction","sweepPath","isAssignmentExpression","isVariableDeclarator","sweepImport","parent","crawl","beforeCount"],"mappings":"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"}