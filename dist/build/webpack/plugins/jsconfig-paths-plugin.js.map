{"version":3,"sources":["../../../../build/webpack/plugins/jsconfig-paths-plugin.ts"],"sourcesContent":["/**\n * This webpack resolver is largely based on TypeScript's \"paths\" handling\n * The TypeScript license can be found here:\n * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n */\nimport path from 'path'\nimport { webpack } from 'next/dist/compiled/webpack/webpack'\nimport { debug } from 'next/dist/compiled/debug'\n\nconst log = debug('next:jsconfig-paths-plugin')\n\nexport interface Pattern {\n  prefix: string\n  suffix: string\n}\n\nconst asterisk = 0x2a\n\nexport function hasZeroOrOneAsteriskCharacter(str: string): boolean {\n  let seenAsterisk = false\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true\n      } else {\n        // have already seen asterisk\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * Determines whether a path starts with a relative path component (i.e. `.` or `..`).\n */\nexport function pathIsRelative(testPath: string): boolean {\n  return /^\\.\\.?($|[\\\\/])/.test(testPath)\n}\n\nexport function tryParsePattern(pattern: string): Pattern | undefined {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf('*')\n  return indexOfStar === -1\n    ? undefined\n    : {\n        prefix: pattern.substr(0, indexOfStar),\n        suffix: pattern.substr(indexOfStar + 1),\n      }\n}\n\nfunction isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\n  return (\n    candidate.length >= prefix.length + suffix.length &&\n    candidate.startsWith(prefix) &&\n    candidate.endsWith(suffix)\n  )\n}\n\n/** Return the object corresponding to the best pattern to match `candidate`. */\nexport function findBestPatternMatch<T>(\n  values: readonly T[],\n  getPattern: (value: T) => Pattern,\n  candidate: string\n): T | undefined {\n  let matchedValue: T | undefined\n  // use length of prefix as betterness criteria\n  let longestMatchPrefixLength = -1\n\n  for (const v of values) {\n    const pattern = getPattern(v)\n    if (\n      isPatternMatch(pattern, candidate) &&\n      pattern.prefix.length > longestMatchPrefixLength\n    ) {\n      longestMatchPrefixLength = pattern.prefix.length\n      matchedValue = v\n    }\n  }\n\n  return matchedValue\n}\n\n/**\n * patternStrings contains both pattern strings (containing \"*\") and regular strings.\n * Return an exact match if possible, or a pattern match, or undefined.\n * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n */\nexport function matchPatternOrExact(\n  patternStrings: readonly string[],\n  candidate: string\n): string | Pattern | undefined {\n  const patterns: Pattern[] = []\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue\n    const pattern = tryParsePattern(patternString)\n    if (pattern) {\n      patterns.push(pattern)\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString\n    }\n  }\n\n  return findBestPatternMatch(patterns, (_) => _, candidate)\n}\n\n/**\n * Tests whether a value is string\n */\nexport function isString(text: unknown): text is string {\n  return typeof text === 'string'\n}\n\n/**\n * Given that candidate matches pattern, returns the text matching the '*'.\n * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n */\nexport function matchedText(pattern: Pattern, candidate: string): string {\n  return candidate.substring(\n    pattern.prefix.length,\n    candidate.length - pattern.suffix.length\n  )\n}\n\nexport function patternText({ prefix, suffix }: Pattern): string {\n  return `${prefix}*${suffix}`\n}\n\n/**\n * Calls the iterator function for each entry of the array\n * until the first result or error is reached\n */\nfunction forEachBail<TEntry>(\n  array: TEntry[],\n  iterator: (\n    entry: TEntry,\n    entryCallback: (err?: any, result?: any) => void\n  ) => void,\n  callback: (err?: any, result?: any) => void\n): void {\n  if (array.length === 0) return callback()\n\n  let i = 0\n  const next = () => {\n    let loop: boolean | undefined = undefined\n    iterator(array[i++], (err, result) => {\n      if (err || result !== undefined || i >= array.length) {\n        return callback(err, result)\n      }\n      if (loop === false) while (next());\n      loop = true\n    })\n    if (!loop) loop = false\n    return loop\n  }\n  while (next());\n}\n\nconst NODE_MODULES_REGEX = /node_modules/\n\ntype Paths = { [match: string]: string[] }\n\n/**\n * Handles tsconfig.json or jsconfig.js \"paths\" option for webpack\n * Largely based on how the TypeScript compiler handles it:\n * https://github.com/microsoft/TypeScript/blob/1a9c8197fffe3dace5f8dca6633d450a88cba66d/src/compiler/moduleNameResolver.ts#L1362\n */\nexport class JsConfigPathsPlugin implements webpack.ResolvePlugin {\n  paths: Paths\n  resolvedBaseUrl: string\n  constructor(paths: Paths, resolvedBaseUrl: string) {\n    this.paths = paths\n    this.resolvedBaseUrl = resolvedBaseUrl\n    log('tsconfig.json or jsconfig.json paths: %O', paths)\n    log('resolved baseUrl: %s', resolvedBaseUrl)\n  }\n  apply(resolver: any) {\n    const paths = this.paths\n    const pathsKeys = Object.keys(paths)\n\n    // If no aliases are added bail out\n    if (pathsKeys.length === 0) {\n      log('paths are empty, bailing out')\n      return\n    }\n\n    const baseDirectory = this.resolvedBaseUrl\n    const target = resolver.ensureHook('resolve')\n    resolver\n      .getHook('described-resolve')\n      .tapAsync(\n        'JsConfigPathsPlugin',\n        (\n          request: any,\n          resolveContext: any,\n          callback: (err?: any, result?: any) => void\n        ) => {\n          const moduleName = request.request\n\n          // Exclude node_modules from paths support (speeds up resolving)\n          if (request.path.match(NODE_MODULES_REGEX)) {\n            log('skipping request as it is inside node_modules %s', moduleName)\n            return callback()\n          }\n\n          if (\n            path.posix.isAbsolute(moduleName) ||\n            (process.platform === 'win32' && path.win32.isAbsolute(moduleName))\n          ) {\n            log('skipping request as it is an absolute path %s', moduleName)\n            return callback()\n          }\n\n          if (pathIsRelative(moduleName)) {\n            log('skipping request as it is a relative path %s', moduleName)\n            return callback()\n          }\n\n          // log('starting to resolve request %s', moduleName)\n\n          // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n          const matchedPattern = matchPatternOrExact(pathsKeys, moduleName)\n          if (!matchedPattern) {\n            log('moduleName did not match any paths pattern %s', moduleName)\n            return callback()\n          }\n\n          const matchedStar = isString(matchedPattern)\n            ? undefined\n            : matchedText(matchedPattern, moduleName)\n          const matchedPatternText = isString(matchedPattern)\n            ? matchedPattern\n            : patternText(matchedPattern)\n\n          let triedPaths = []\n\n          forEachBail(\n            paths[matchedPatternText],\n            (subst, pathCallback) => {\n              const curPath = matchedStar\n                ? subst.replace('*', matchedStar)\n                : subst\n              // Ensure .d.ts is not matched\n              if (curPath.endsWith('.d.ts')) {\n                // try next path candidate\n                return pathCallback()\n              }\n              const candidate = path.join(baseDirectory, curPath)\n              const obj = Object.assign({}, request, {\n                request: candidate,\n              })\n              resolver.doResolve(\n                target,\n                obj,\n                `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`,\n                resolveContext,\n                (resolverErr: any, resolverResult: any) => {\n                  if (resolverErr || resolverResult === undefined) {\n                    triedPaths.push(candidate)\n                    // try next path candidate\n                    return pathCallback()\n                  }\n                  return pathCallback(resolverErr, resolverResult)\n                }\n              )\n            },\n            callback\n          )\n        }\n      )\n  }\n}\n"],"names":["hasZeroOrOneAsteriskCharacter","pathIsRelative","tryParsePattern","findBestPatternMatch","matchPatternOrExact","isString","matchedText","patternText","log","asterisk","str","seenAsterisk","i","length","charCodeAt","testPath","test","pattern","indexOfStar","indexOf","undefined","prefix","substr","suffix","isPatternMatch","candidate","startsWith","endsWith","values","getPattern","matchedValue","longestMatchPrefixLength","v","patternStrings","patterns","patternString","push","_","text","substring","forEachBail","array","iterator","callback","next","loop","err","result","NODE_MODULES_REGEX","JsConfigPathsPlugin","paths","resolvedBaseUrl","apply","resolver","pathsKeys","Object","keys","baseDirectory","target","ensureHook","getHook","tapAsync","request","resolveContext","moduleName","path","match","posix","isAbsolute","process","platform","win32","matchedPattern","matchedStar","matchedPatternText","triedPaths","subst","pathCallback","curPath","replace","join","obj","assign","doResolve","resolverErr","resolverResult"],"mappings":"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"}